import type { GeneratedSignal, PayoutState, SlotSignal, LiveSignal } from '../types';

// Heuristic constants for time calculation
const TIME_PER_SLOT_ATTEMPT_S = 10; // Time to switch modes (normal/turbo/auto)
const TIME_PER_SLOT_ROUND_S = 4;    // Average time for one slot spin
const TIME_PER_LIVE_STEP_S = 45;    // Time for a live game round + decision

/**
 * Parses a "HH:MM - HH:MM" time string relative to a generation timestamp.
 * @param timeRange The time string to parse.
 * @param generatedAt The timestamp when the signal was generated.
 * @returns An object with start Date, end Date, and duration in seconds, or null if parsing fails.
 */
function parseTimeRange(timeRange: string, generatedAt: number): { start: Date, end: Date, durationSeconds: number } | null {
    const timeMatch = timeRange.match(/(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})/);
    if (!timeMatch) return null;

    try {
        const [, startTimeStr, endTimeStr] = timeMatch;
        const [startHours, startMinutes] = startTimeStr.split(':').map(Number);
        const [endHours, endMinutes] = endTimeStr.split(':').map(Number);
        
        const generationDate = new Date(generatedAt);
        
        let start = new Date(generationDate);
        start.setHours(startHours, startMinutes, 0, 0);

        let end = new Date(generationDate);
        end.setHours(endHours, endMinutes, 0, 0);

        // Handle overnight case where end time is on the next day
        if (end < start) {
            end.setDate(end.getDate() + 1);
        }
        
        const durationSeconds = (end.getTime() - start.getTime()) / 1000;
        return { start, end, durationSeconds };

    } catch (e) {
        console.error("Error parsing time range:", timeRange, e);
        return null;
    }
}

/**
 * Formats a Date object into a "HH:MM" string.
 * @param d The Date object to format.
 * @returns A formatted time string.
 */
function formatTime(d: Date): string {
    return d.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
}


/**
 * Validates and adjusts a generated signal for time feasibility and phase change security.
 * This acts as a security layer between the AI generation and the user display.
 * @param signal The signal generated by the AI.
 * @param payoutState The current payout state of the game.
 * @returns The validated and potentially adjusted signal.
 */
export const validateAndAdjustSignal = (
    signal: GeneratedSignal,
    payoutState: PayoutState,
): GeneratedSignal => {
    let adjustedSignal = JSON.parse(JSON.stringify(signal)); // Deep copy to ensure mutability
    const now = Date.now();

    // --- 1. Payout Phase Security Check ---
    // Intercepts signals generated in the "danger zone" (high phase about to turn low).
    const isDangerZone = payoutState.isChangingSoon && payoutState.nextPhase === 'low';
    const phaseEndTime = new Date(payoutState.phaseEndTime);

    if (isDangerZone) {
        // Shorten the time window to end safely before the phase change.
        // Cap the duration at a max of 3 minutes for a quick, safe exit.
        const safeEndTime = new Date(Math.min(phaseEndTime.getTime() - 30 * 1000, now + 3 * 60 * 1000));
        const newStartTime = new Date(now + 20 * 1000); // Start in 20s for urgency

        if (newStartTime < safeEndTime) {
             adjustedSignal.payingTimeSuggestion = `${formatTime(newStartTime)} - ${formatTime(safeEndTime)}`;
        } else {
             const minimalEndTime = new Date(newStartTime.getTime() + 60 * 1000);
             adjustedSignal.payingTimeSuggestion = `${formatTime(newStartTime)} - ${formatTime(minimalEndTime)}`;
        }

        // Make the strategy itself more conservative
        if (adjustedSignal.signalType === 'slot') {
            const slotSignal = adjustedSignal as SlotSignal;
            slotSignal.strategyProfile = 'Cauteloso';
            // Cut down to 2 safest attempts
            slotSignal.attempts = slotSignal.attempts.slice(0, 2).map(attempt => ({
                type: 'Normal', // Force Normal mode
                rounds: Math.max(4, Math.min(attempt.rounds, 6)) // Cap rounds to a safe 4-6 range
            }));
            slotSignal.strategyTips = `ALERTA: Fase de ALTA prestes a terminar! Estratégia curta para um ganho rápido e seguro antes da mudança. Risco elevado.`;
        } else if (adjustedSignal.signalType === 'live') {
            const liveSignal = adjustedSignal as LiveSignal;
            liveSignal.riskProfile = 'Alto';
            liveSignal.sessionGoal = 'Objetivo: 1-2 ganhos rápidos e sair. ALERTA: A fase de pagamento vai cair, jogue com extrema cautela.';
        }
    }


    // --- 2. Time Feasibility Check ---
    const timeDetails = parseTimeRange(adjustedSignal.payingTimeSuggestion, now);
    if (!timeDetails) {
        return adjustedSignal; // Cannot parse, return as is
    }

    let requiredSeconds = 0;
    if (adjustedSignal.signalType === 'slot') {
        const slotSignal = adjustedSignal as SlotSignal;
        requiredSeconds = slotSignal.attempts.reduce((total, attempt) => 
            total + TIME_PER_SLOT_ATTEMPT_S + (attempt.rounds * TIME_PER_SLOT_ROUND_S), 0);
    } else if (adjustedSignal.signalType === 'live') {
        const liveSignal = adjustedSignal as LiveSignal;
        requiredSeconds = (liveSignal.bettingPlan?.length || 0) * TIME_PER_LIVE_STEP_S;
    }
    
    requiredSeconds *= 1.1; // Add a 10% buffer

    // If generated time is not enough, extend it, but not beyond the phase end.
    if (timeDetails.durationSeconds < requiredSeconds) {
        const requiredEndTime = new Date(timeDetails.start.getTime() + requiredSeconds * 1000);
        
        // Ensure the new end time doesn't exceed the phase end time (minus a 30s buffer)
        const safePhaseEndTime = new Date(payoutState.phaseEndTime - 30 * 1000);
        const newEndTime = new Date(Math.min(requiredEndTime.getTime(), safePhaseEndTime.getTime()));
        
        if (newEndTime > timeDetails.start) {
            adjustedSignal.payingTimeSuggestion = `${formatTime(timeDetails.start)} - ${formatTime(newEndTime)}`;
            
            if (adjustedSignal.signalType === 'slot') {
                 (adjustedSignal as SlotSignal).strategyTips += ` (Aviso: A duração foi ajustada para garantir a execução completa da estratégia dentro da fase de pagamento.)`;
            }
        }
    }
    
    return adjustedSignal;
};
